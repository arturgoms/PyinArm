   1               		.file	"usb.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.usb_wait_in_ready,"ax",@progbits
  12               	usb_wait_in_ready:
  13               	.LFB9:
  14               		.file 1 "usb.c"
   1:usb.c         **** /* Teensy Rebootor
   2:usb.c         ****  * http://www.pjrc.com/teensy/
   3:usb.c         ****  * Copyright (c) 2010 PJRC.COM, LLC
   4:usb.c         ****  * 
   5:usb.c         ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   6:usb.c         ****  * of this software and associated documentation files (the "Software"), to deal
   7:usb.c         ****  * in the Software without restriction, including without limitation the rights
   8:usb.c         ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   9:usb.c         ****  * copies of the Software, and to permit persons to whom the Software is
  10:usb.c         ****  * furnished to do so, subject to the following conditions:
  11:usb.c         ****  * 
  12:usb.c         ****  * The above description, website URL and copyright notice and this permission
  13:usb.c         ****  * notice shall be included in all copies or substantial portions of the Software.
  14:usb.c         ****  * 
  15:usb.c         ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:usb.c         ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  17:usb.c         ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  18:usb.c         ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  19:usb.c         ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  20:usb.c         ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  21:usb.c         ****  * THE SOFTWARE.
  22:usb.c         ****  */
  23:usb.c         **** 
  24:usb.c         **** // Version 1.0: Initial Release
  25:usb.c         **** 
  26:usb.c         **** #define USB_PRIVATE_INCLUDE
  27:usb.c         **** #include "usb.h"
  28:usb.c         **** #include <util/delay.h>
  29:usb.c         **** 
  30:usb.c         **** /**************************************************************************
  31:usb.c         ****  *
  32:usb.c         ****  *  Configurable Options
  33:usb.c         ****  *
  34:usb.c         ****  **************************************************************************/
  35:usb.c         **** 
  36:usb.c         **** #define STR_MANUFACTURER	L"PJRC"
  37:usb.c         **** #define STR_PRODUCT		L"Rebootor"
  38:usb.c         **** #define VENDOR_ID		0x16C0
  39:usb.c         **** #define PRODUCT_ID		0x0477
  40:usb.c         **** #define RX_SIZE			6	// receive packet size
  41:usb.c         **** 
  42:usb.c         **** 
  43:usb.c         **** /**************************************************************************
  44:usb.c         ****  *
  45:usb.c         ****  *  Endpoint Buffer Configuration
  46:usb.c         ****  *
  47:usb.c         ****  **************************************************************************/
  48:usb.c         **** 
  49:usb.c         **** #define ENDPOINT0_SIZE		32
  50:usb.c         **** 
  51:usb.c         **** 
  52:usb.c         **** static const uint8_t PROGMEM endpoint_config_table[] = {
  53:usb.c         **** 	1, EP_TYPE_INTERRUPT_IN,  EP_SIZE(8) | EP_SINGLE_BUFFER,
  54:usb.c         **** 	0,
  55:usb.c         **** 	0,
  56:usb.c         **** 	0
  57:usb.c         **** };
  58:usb.c         **** 
  59:usb.c         **** 
  60:usb.c         **** /**************************************************************************
  61:usb.c         ****  *
  62:usb.c         ****  *  Descriptor Data
  63:usb.c         ****  *
  64:usb.c         ****  **************************************************************************/
  65:usb.c         **** 
  66:usb.c         **** // Descriptors are the data that your computer reads when it auto-detects
  67:usb.c         **** // this USB device (called "enumeration" in USB lingo).  The most commonly
  68:usb.c         **** // changed items are editable at the top of this file.  Changing things
  69:usb.c         **** // in here should only be done by those who've read chapter 9 of the USB
  70:usb.c         **** // spec and relevant portions of any USB class specifications!
  71:usb.c         **** 
  72:usb.c         **** 
  73:usb.c         **** const uint8_t PROGMEM device_descriptor[] = {
  74:usb.c         **** 	18,					// bLength
  75:usb.c         **** 	1,					// bDescriptorType
  76:usb.c         **** 	0x00, 0x02,				// bcdUSB
  77:usb.c         **** 	0,					// bDeviceClass
  78:usb.c         **** 	0,					// bDeviceSubClass
  79:usb.c         **** 	0,					// bDeviceProtocol
  80:usb.c         **** 	ENDPOINT0_SIZE,				// bMaxPacketSize0
  81:usb.c         **** 	LSB(VENDOR_ID), MSB(VENDOR_ID),		// idVendor
  82:usb.c         **** 	LSB(PRODUCT_ID), MSB(PRODUCT_ID),	// idProduct
  83:usb.c         **** 	0x00, 0x01,				// bcdDevice
  84:usb.c         **** 	1,					// iManufacturer
  85:usb.c         **** 	2,					// iProduct
  86:usb.c         **** 	0,					// iSerialNumber
  87:usb.c         **** 	1					// bNumConfigurations
  88:usb.c         **** };
  89:usb.c         **** 
  90:usb.c         **** const uint8_t PROGMEM rawhid_hid_report_desc[] = {
  91:usb.c         **** 	0x06, 0x00, 0xFF,
  92:usb.c         **** 	0x0A, 0x00, 0x01,
  93:usb.c         **** 	0xA1, 0x01,				// Collection 0x01
  94:usb.c         **** 	0x75, 0x08,				// report size = 8 bits
  95:usb.c         **** 	0x15, 0x00,				// logical minimum = 0
  96:usb.c         **** 	0x26, 0xFF, 0x00,			// logical maximum = 255
  97:usb.c         **** 	0x95, RX_SIZE,				// report count
  98:usb.c         **** 	0x09, 0x02,				// usage
  99:usb.c         **** 	0x91, 0x02,				// Output (array)
 100:usb.c         **** 	0xC0					// end collection
 101:usb.c         **** };
 102:usb.c         **** 
 103:usb.c         **** 
 104:usb.c         **** #define CONFIG1_DESC_SIZE        (9+9+9+7)
 105:usb.c         **** #define RAWHID_HID_DESC_OFFSET   (9+9)
 106:usb.c         **** const uint8_t PROGMEM config1_descriptor[CONFIG1_DESC_SIZE] = {
 107:usb.c         **** 	// configuration descriptor, USB spec 9.6.3, page 264-266, Table 9-10
 108:usb.c         **** 	9, 					// bLength;
 109:usb.c         **** 	2,					// bDescriptorType;
 110:usb.c         **** 	LSB(CONFIG1_DESC_SIZE),			// wTotalLength
 111:usb.c         **** 	MSB(CONFIG1_DESC_SIZE),
 112:usb.c         **** 	1,					// bNumInterfaces
 113:usb.c         **** 	1,					// bConfigurationValue
 114:usb.c         **** 	0,					// iConfiguration
 115:usb.c         **** 	0xC0,					// bmAttributes
 116:usb.c         **** 	50,					// bMaxPower
 117:usb.c         **** 
 118:usb.c         **** 	// interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
 119:usb.c         **** 	9,					// bLength
 120:usb.c         **** 	4,					// bDescriptorType
 121:usb.c         **** 	0,					// bInterfaceNumber
 122:usb.c         **** 	0,					// bAlternateSetting
 123:usb.c         **** 	1,					// bNumEndpoints
 124:usb.c         **** 	0x03,					// bInterfaceClass (0x03 = HID)
 125:usb.c         **** 	0x00,					// bInterfaceSubClass
 126:usb.c         **** 	0x00,					// bInterfaceProtocol
 127:usb.c         **** 	0,					// iInterface
 128:usb.c         **** 	// HID interface descriptor, HID 1.11 spec, section 6.2.1
 129:usb.c         **** 	9,					// bLength
 130:usb.c         **** 	0x21,					// bDescriptorType
 131:usb.c         **** 	0x11, 0x01,				// bcdHID
 132:usb.c         **** 	0,					// bCountryCode
 133:usb.c         **** 	1,					// bNumDescriptors
 134:usb.c         **** 	0x22,					// bDescriptorType
 135:usb.c         **** 	sizeof(rawhid_hid_report_desc),		// wDescriptorLength
 136:usb.c         **** 	0,
 137:usb.c         **** 	// endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
 138:usb.c         **** 	7,					// bLength
 139:usb.c         **** 	5,					// bDescriptorType
 140:usb.c         **** 	1 | 0x80,				// bEndpointAddress
 141:usb.c         **** 	0x03,					// bmAttributes (0x03=intr)
 142:usb.c         **** 	8, 0,					// wMaxPacketSize
 143:usb.c         **** 	0x80					// bInterval
 144:usb.c         **** };
 145:usb.c         **** 
 146:usb.c         **** // If you're desperate for a little extra code memory, these strings
 147:usb.c         **** // can be completely removed if iManufacturer, iProduct, iSerialNumber
 148:usb.c         **** // in the device desciptor are changed to zeros.
 149:usb.c         **** struct usb_string_descriptor_struct {
 150:usb.c         **** 	uint8_t bLength;
 151:usb.c         **** 	uint8_t bDescriptorType;
 152:usb.c         **** 	int16_t wString[];
 153:usb.c         **** };
 154:usb.c         **** const struct usb_string_descriptor_struct PROGMEM string0 = {
 155:usb.c         **** 	4,
 156:usb.c         **** 	3,
 157:usb.c         **** 	{0x0409}
 158:usb.c         **** };
 159:usb.c         **** const struct usb_string_descriptor_struct PROGMEM string1 = {
 160:usb.c         **** 	sizeof(STR_MANUFACTURER),
 161:usb.c         **** 	3,
 162:usb.c         **** 	STR_MANUFACTURER
 163:usb.c         **** };
 164:usb.c         **** const struct usb_string_descriptor_struct PROGMEM string2 = {
 165:usb.c         **** 	sizeof(STR_PRODUCT),
 166:usb.c         **** 	3,
 167:usb.c         **** 	STR_PRODUCT
 168:usb.c         **** };
 169:usb.c         **** 
 170:usb.c         **** // This table defines which descriptor data is sent for each specific
 171:usb.c         **** // request from the host (in wValue and wIndex).
 172:usb.c         **** const struct descriptor_list_struct {
 173:usb.c         **** 	uint16_t	wValue;
 174:usb.c         **** 	uint16_t	wIndex;
 175:usb.c         **** 	const uint8_t	*addr;
 176:usb.c         **** 	uint8_t		length;
 177:usb.c         **** } PROGMEM descriptor_list[] = {
 178:usb.c         **** 	{0x0100, 0x0000, device_descriptor, sizeof(device_descriptor)},
 179:usb.c         **** 	{0x0200, 0x0000, config1_descriptor, sizeof(config1_descriptor)},
 180:usb.c         **** 	{0x2200, 0, rawhid_hid_report_desc, sizeof(rawhid_hid_report_desc)},
 181:usb.c         **** 	{0x2100, 0, config1_descriptor+RAWHID_HID_DESC_OFFSET, 9},
 182:usb.c         **** 	{0x0300, 0x0000, (const uint8_t *)&string0, 4},
 183:usb.c         **** 	{0x0301, 0x0409, (const uint8_t *)&string1, sizeof(STR_MANUFACTURER)},
 184:usb.c         **** 	{0x0302, 0x0409, (const uint8_t *)&string2, sizeof(STR_PRODUCT)}
 185:usb.c         **** };
 186:usb.c         **** #define NUM_DESC_LIST (sizeof(descriptor_list)/sizeof(struct descriptor_list_struct))
 187:usb.c         **** 
 188:usb.c         **** 
 189:usb.c         **** /**************************************************************************
 190:usb.c         ****  *
 191:usb.c         ****  *  Variables - these are the only non-stack RAM usage
 192:usb.c         ****  *
 193:usb.c         ****  **************************************************************************/
 194:usb.c         **** 
 195:usb.c         **** // zero when we are not configured, non-zero when enumerated
 196:usb.c         **** static volatile uint8_t usb_configuration=0;
 197:usb.c         **** 
 198:usb.c         **** 
 199:usb.c         **** 
 200:usb.c         **** /**************************************************************************
 201:usb.c         ****  *
 202:usb.c         ****  *  Public Functions - these are the API intended for the user
 203:usb.c         ****  *
 204:usb.c         ****  **************************************************************************/
 205:usb.c         **** 
 206:usb.c         **** 
 207:usb.c         **** // initialize USB
 208:usb.c         **** void usb_init(void)
 209:usb.c         **** {
 210:usb.c         **** 	HW_CONFIG();
 211:usb.c         **** 	USB_FREEZE();				// enable USB
 212:usb.c         **** 	PLL_CONFIG();				// config PLL
 213:usb.c         ****         while (!(PLLCSR & (1<<PLOCK))) ;	// wait for PLL lock
 214:usb.c         ****         USB_CONFIG();				// start USB clock
 215:usb.c         ****         UDCON = 0;				// enable attach resistor
 216:usb.c         **** 	usb_configuration = 0;
 217:usb.c         ****         UDIEN = (1<<EORSTE);
 218:usb.c         **** 	sei();
 219:usb.c         **** }
 220:usb.c         **** 
 221:usb.c         **** 
 222:usb.c         **** 
 223:usb.c         **** /**************************************************************************
 224:usb.c         ****  *
 225:usb.c         ****  *  Private Functions - not intended for general user consumption....
 226:usb.c         ****  *
 227:usb.c         ****  **************************************************************************/
 228:usb.c         **** 
 229:usb.c         **** 
 230:usb.c         **** #if (GCC_VERSION >= 40300) && (GCC_VERSION < 40302)
 231:usb.c         **** #error "Buggy GCC 4.3.0 compiler, please upgrade!"
 232:usb.c         **** #endif
 233:usb.c         **** 
 234:usb.c         **** 
 235:usb.c         **** // USB Device Interrupt - handle all device-level events
 236:usb.c         **** // the transmit buffer flushing is triggered by the start of frame
 237:usb.c         **** //
 238:usb.c         **** ISR(USB_GEN_vect)
 239:usb.c         **** {
 240:usb.c         **** 	uint8_t intbits;
 241:usb.c         **** 
 242:usb.c         ****         intbits = UDINT;
 243:usb.c         ****         UDINT = 0;
 244:usb.c         ****         if (intbits & (1<<EORSTI)) {
 245:usb.c         **** 		UENUM = 0;
 246:usb.c         **** 		UECONX = 1;
 247:usb.c         **** 		UECFG0X = EP_TYPE_CONTROL;
 248:usb.c         **** 		UECFG1X = EP_SIZE(ENDPOINT0_SIZE) | EP_SINGLE_BUFFER;
 249:usb.c         **** 		UEIENX = (1<<RXSTPE);
 250:usb.c         **** 		usb_configuration = 0;
 251:usb.c         ****         }
 252:usb.c         **** }
 253:usb.c         **** 
 254:usb.c         **** 
 255:usb.c         **** 
 256:usb.c         **** // Misc functions to wait for ready and send/receive packets
 257:usb.c         **** static inline void usb_wait_in_ready(void)
 258:usb.c         **** {
  15               		.loc 1 258 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 259:usb.c         **** 	while (!(UEINTX & (1<<TXINI))) ;
  22               		.loc 1 259 0 discriminator 1
  23 0000 8091 E800 		lds r24,232
  24 0004 80FF      		sbrs r24,0
  25 0006 00C0      		rjmp .L2
  26               	/* epilogue start */
 260:usb.c         **** }
  27               		.loc 1 260 0
  28 0008 0895      		ret
  29               		.cfi_endproc
  30               	.LFE9:
  32               		.section	.text.usb_init,"ax",@progbits
  33               	.global	usb_init
  35               	usb_init:
  36               	.LFB7:
 209:usb.c         **** 	HW_CONFIG();
  37               		.loc 1 209 0
  38               		.cfi_startproc
  39               	/* prologue: function */
  40               	/* frame size = 0 */
  41               	/* stack size = 0 */
  42               	.L__stack_usage = 0
 210:usb.c         **** 	USB_FREEZE();				// enable USB
  43               		.loc 1 210 0
  44 0000 81E0      		ldi r24,lo8(1)
  45 0002 8093 D700 		sts 215,r24
 211:usb.c         **** 	PLL_CONFIG();				// config PLL
  46               		.loc 1 211 0
  47 0006 80EA      		ldi r24,lo8(-96)
  48 0008 8093 D800 		sts 216,r24
 212:usb.c         ****         while (!(PLLCSR & (1<<PLOCK))) ;	// wait for PLL lock
  49               		.loc 1 212 0
  50 000c 82E1      		ldi r24,lo8(18)
  51 000e 89BD      		out 0x29,r24
  52               	.L6:
 213:usb.c         ****         USB_CONFIG();				// start USB clock
  53               		.loc 1 213 0 discriminator 1
  54 0010 09B4      		in __tmp_reg__,0x29
  55 0012 00FE      		sbrs __tmp_reg__,0
  56 0014 00C0      		rjmp .L6
 214:usb.c         ****         UDCON = 0;				// enable attach resistor
  57               		.loc 1 214 0
  58 0016 80E9      		ldi r24,lo8(-112)
  59 0018 8093 D800 		sts 216,r24
 215:usb.c         **** 	usb_configuration = 0;
  60               		.loc 1 215 0
  61 001c 1092 E000 		sts 224,__zero_reg__
 216:usb.c         ****         UDIEN = (1<<EORSTE);
  62               		.loc 1 216 0
  63 0020 1092 0000 		sts usb_configuration,__zero_reg__
 217:usb.c         **** 	sei();
  64               		.loc 1 217 0
  65 0024 88E0      		ldi r24,lo8(8)
  66 0026 8093 E200 		sts 226,r24
 218:usb.c         **** }
  67               		.loc 1 218 0
  68               	/* #APP */
  69               	 ;  218 "usb.c" 1
  70 002a 7894      		sei
  71               	 ;  0 "" 2
  72               	/* #NOAPP */
  73 002c 0895      		ret
  74               		.cfi_endproc
  75               	.LFE7:
  77               		.section	.text.__vector_10,"ax",@progbits
  78               	.global	__vector_10
  80               	__vector_10:
  81               	.LFB8:
 239:usb.c         **** 	uint8_t intbits;
  82               		.loc 1 239 0
  83               		.cfi_startproc
  84 0000 1F92      		push r1
  85               	.LCFI0:
  86               		.cfi_def_cfa_offset 3
  87               		.cfi_offset 1, -2
  88 0002 0F92      		push r0
  89               	.LCFI1:
  90               		.cfi_def_cfa_offset 4
  91               		.cfi_offset 0, -3
  92 0004 0FB6      		in r0,__SREG__
  93 0006 0F92      		push r0
  94 0008 1124      		clr __zero_reg__
  95 000a 8F93      		push r24
  96               	.LCFI2:
  97               		.cfi_def_cfa_offset 5
  98               		.cfi_offset 24, -4
  99               	/* prologue: Signal */
 100               	/* frame size = 0 */
 101               	/* stack size = 4 */
 102               	.L__stack_usage = 4
 242:usb.c         ****         UDINT = 0;
 103               		.loc 1 242 0
 104 000c 8091 E100 		lds r24,225
 105               	.LVL0:
 243:usb.c         ****         if (intbits & (1<<EORSTI)) {
 106               		.loc 1 243 0
 107 0010 1092 E100 		sts 225,__zero_reg__
 244:usb.c         **** 		UENUM = 0;
 108               		.loc 1 244 0
 109 0014 83FF      		sbrs r24,3
 110 0016 00C0      		rjmp .L9
 245:usb.c         **** 		UECONX = 1;
 111               		.loc 1 245 0
 112 0018 1092 E900 		sts 233,__zero_reg__
 246:usb.c         **** 		UECFG0X = EP_TYPE_CONTROL;
 113               		.loc 1 246 0
 114 001c 81E0      		ldi r24,lo8(1)
 115               	.LVL1:
 116 001e 8093 EB00 		sts 235,r24
 247:usb.c         **** 		UECFG1X = EP_SIZE(ENDPOINT0_SIZE) | EP_SINGLE_BUFFER;
 117               		.loc 1 247 0
 118 0022 1092 EC00 		sts 236,__zero_reg__
 248:usb.c         **** 		UEIENX = (1<<RXSTPE);
 119               		.loc 1 248 0
 120 0026 82E2      		ldi r24,lo8(34)
 121 0028 8093 ED00 		sts 237,r24
 249:usb.c         **** 		usb_configuration = 0;
 122               		.loc 1 249 0
 123 002c 88E0      		ldi r24,lo8(8)
 124 002e 8093 F000 		sts 240,r24
 250:usb.c         ****         }
 125               		.loc 1 250 0
 126 0032 1092 0000 		sts usb_configuration,__zero_reg__
 127               	.L9:
 128               	/* epilogue start */
 252:usb.c         **** 
 129               		.loc 1 252 0
 130 0036 8F91      		pop r24
 131 0038 0F90      		pop r0
 132 003a 0FBE      		out __SREG__,r0
 133 003c 0F90      		pop r0
 134 003e 1F90      		pop r1
 135 0040 1895      		reti
 136               		.cfi_endproc
 137               	.LFE8:
 139               		.section	.text.__vector_11,"ax",@progbits
 140               	.global	__vector_11
 142               	__vector_11:
 143               	.LFB13:
 261:usb.c         **** static inline void usb_send_in(void)
 262:usb.c         **** {
 263:usb.c         **** 	UEINTX = ~(1<<TXINI);
 264:usb.c         **** }
 265:usb.c         **** static inline void usb_wait_receive_out(void)
 266:usb.c         **** {
 267:usb.c         **** 	while (!(UEINTX & (1<<RXOUTI))) ;
 268:usb.c         **** }
 269:usb.c         **** static inline void usb_ack_out(void)
 270:usb.c         **** {
 271:usb.c         **** 	UEINTX = ~(1<<RXOUTI);
 272:usb.c         **** }
 273:usb.c         **** 
 274:usb.c         **** 
 275:usb.c         **** 
 276:usb.c         **** // USB Endpoint Interrupt - endpoint 0 is handled here.  The
 277:usb.c         **** // other endpoints are manipulated by the user-callable
 278:usb.c         **** // functions, and the start-of-frame interrupt.
 279:usb.c         **** //
 280:usb.c         **** ISR(USB_COM_vect)
 281:usb.c         **** {
 144               		.loc 1 281 0
 145               		.cfi_startproc
 146 0000 1F92      		push r1
 147               	.LCFI3:
 148               		.cfi_def_cfa_offset 3
 149               		.cfi_offset 1, -2
 150 0002 0F92      		push r0
 151               	.LCFI4:
 152               		.cfi_def_cfa_offset 4
 153               		.cfi_offset 0, -3
 154 0004 0FB6      		in r0,__SREG__
 155 0006 0F92      		push r0
 156 0008 1124      		clr __zero_reg__
 157 000a EF92      		push r14
 158               	.LCFI5:
 159               		.cfi_def_cfa_offset 5
 160               		.cfi_offset 14, -4
 161 000c FF92      		push r15
 162               	.LCFI6:
 163               		.cfi_def_cfa_offset 6
 164               		.cfi_offset 15, -5
 165 000e 0F93      		push r16
 166               	.LCFI7:
 167               		.cfi_def_cfa_offset 7
 168               		.cfi_offset 16, -6
 169 0010 1F93      		push r17
 170               	.LCFI8:
 171               		.cfi_def_cfa_offset 8
 172               		.cfi_offset 17, -7
 173 0012 2F93      		push r18
 174               	.LCFI9:
 175               		.cfi_def_cfa_offset 9
 176               		.cfi_offset 18, -8
 177 0014 3F93      		push r19
 178               	.LCFI10:
 179               		.cfi_def_cfa_offset 10
 180               		.cfi_offset 19, -9
 181 0016 4F93      		push r20
 182               	.LCFI11:
 183               		.cfi_def_cfa_offset 11
 184               		.cfi_offset 20, -10
 185 0018 5F93      		push r21
 186               	.LCFI12:
 187               		.cfi_def_cfa_offset 12
 188               		.cfi_offset 21, -11
 189 001a 6F93      		push r22
 190               	.LCFI13:
 191               		.cfi_def_cfa_offset 13
 192               		.cfi_offset 22, -12
 193 001c 7F93      		push r23
 194               	.LCFI14:
 195               		.cfi_def_cfa_offset 14
 196               		.cfi_offset 23, -13
 197 001e 8F93      		push r24
 198               	.LCFI15:
 199               		.cfi_def_cfa_offset 15
 200               		.cfi_offset 24, -14
 201 0020 9F93      		push r25
 202               	.LCFI16:
 203               		.cfi_def_cfa_offset 16
 204               		.cfi_offset 25, -15
 205 0022 AF93      		push r26
 206               	.LCFI17:
 207               		.cfi_def_cfa_offset 17
 208               		.cfi_offset 26, -16
 209 0024 BF93      		push r27
 210               	.LCFI18:
 211               		.cfi_def_cfa_offset 18
 212               		.cfi_offset 27, -17
 213 0026 CF93      		push r28
 214               	.LCFI19:
 215               		.cfi_def_cfa_offset 19
 216               		.cfi_offset 28, -18
 217 0028 DF93      		push r29
 218               	.LCFI20:
 219               		.cfi_def_cfa_offset 20
 220               		.cfi_offset 29, -19
 221 002a EF93      		push r30
 222               	.LCFI21:
 223               		.cfi_def_cfa_offset 21
 224               		.cfi_offset 30, -20
 225 002c FF93      		push r31
 226               	.LCFI22:
 227               		.cfi_def_cfa_offset 22
 228               		.cfi_offset 31, -21
 229               	/* prologue: Signal */
 230               	/* frame size = 0 */
 231               	/* stack size = 21 */
 232               	.L__stack_usage = 21
 282:usb.c         ****         uint8_t intbits;
 283:usb.c         **** 	const uint8_t *list;
 284:usb.c         ****         const uint8_t *cfg;
 285:usb.c         **** 	uint8_t i, n, len, en;
 286:usb.c         **** 	uint8_t bmRequestType;
 287:usb.c         **** 	uint8_t bRequest;
 288:usb.c         **** 	uint16_t wValue;
 289:usb.c         **** 	uint16_t wIndex;
 290:usb.c         **** 	uint16_t wLength;
 291:usb.c         **** 	uint16_t desc_val;
 292:usb.c         **** 	const uint8_t *desc_addr;
 293:usb.c         **** 	uint8_t	desc_length;
 294:usb.c         **** 
 295:usb.c         ****         UENUM = 0;
 233               		.loc 1 295 0
 234 002e 1092 E900 		sts 233,__zero_reg__
 296:usb.c         **** 	intbits = UEINTX;
 235               		.loc 1 296 0
 236 0032 8091 E800 		lds r24,232
 237               	.LVL2:
 297:usb.c         ****         if (intbits & (1<<RXSTPI)) {
 238               		.loc 1 297 0
 239 0036 83FF      		sbrs r24,3
 240 0038 00C0      		rjmp .L15
 298:usb.c         ****                 bmRequestType = UEDATX;
 241               		.loc 1 298 0
 242 003a D091 F100 		lds r29,241
 243               	.LVL3:
 299:usb.c         ****                 bRequest = UEDATX;
 244               		.loc 1 299 0
 245 003e C091 F100 		lds r28,241
 246               	.LVL4:
 300:usb.c         ****                 wValue = UEDATX;
 247               		.loc 1 300 0
 248 0042 E090 F100 		lds r14,241
 249               	.LVL5:
 301:usb.c         ****                 wValue |= (UEDATX << 8);
 250               		.loc 1 301 0
 251 0046 8091 F100 		lds r24,241
 252               	.LVL6:
 253 004a F12C      		mov r15,__zero_reg__
 254 004c F82A      		or r15,r24
 255               	.LVL7:
 302:usb.c         ****                 wIndex = UEDATX;
 256               		.loc 1 302 0
 257 004e 0091 F100 		lds r16,241
 258               	.LVL8:
 303:usb.c         ****                 wIndex |= (UEDATX << 8);
 259               		.loc 1 303 0
 260 0052 8091 F100 		lds r24,241
 261 0056 10E0      		ldi r17,0
 262 0058 182B      		or r17,r24
 263               	.LVL9:
 304:usb.c         ****                 wLength = UEDATX;
 264               		.loc 1 304 0
 265 005a 8091 F100 		lds r24,241
 266               	.LVL10:
 305:usb.c         ****                 wLength |= (UEDATX << 8);
 267               		.loc 1 305 0
 268 005e 6091 F100 		lds r22,241
 269               	.LVL11:
 306:usb.c         ****                 UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
 270               		.loc 1 306 0
 271 0062 92EF      		ldi r25,lo8(-14)
 272 0064 9093 E800 		sts 232,r25
 307:usb.c         ****                 if (bRequest == GET_DESCRIPTOR) {
 273               		.loc 1 307 0
 274 0068 C630      		cpi r28,lo8(6)
 275 006a 01F0      		breq .+2
 276 006c 00C0      		rjmp .L55
 277 006e 20E0      		ldi r18,lo8(descriptor_list)
 278 0070 30E0      		ldi r19,hi8(descriptor_list)
 279 0072 40E0      		ldi r20,lo8(descriptor_list+49)
 280 0074 50E0      		ldi r21,hi8(descriptor_list+49)
 281               	.L24:
 282               	.LVL12:
 283               	.LBB69:
 308:usb.c         **** 			list = (const uint8_t *)descriptor_list;
 309:usb.c         **** 			for (i=0; ; i++) {
 310:usb.c         **** 				if (i >= NUM_DESC_LIST) {
 311:usb.c         **** 					UECONX = (1<<STALLRQ)|(1<<EPEN);  //stall
 312:usb.c         **** 					return;
 313:usb.c         **** 				}
 314:usb.c         **** 				desc_val = pgm_read_word(list);
 284               		.loc 1 314 0
 285 0076 F901      		movw r30,r18
 286               	/* #APP */
 287               	 ;  314 "usb.c" 1
 288 0078 A591      		lpm r26, Z+
 289 007a B491      		lpm r27, Z
 290               		
 291               	 ;  0 "" 2
 292               	.LVL13:
 293               	/* #NOAPP */
 294               	.LBE69:
 315:usb.c         **** 				if (desc_val != wValue) {
 295               		.loc 1 315 0
 296 007c EA16      		cp r14,r26
 297 007e FB06      		cpc r15,r27
 298 0080 01F0      		breq .+2
 299 0082 00C0      		rjmp .L19
 300               	.LVL14:
 301               	.LBB70:
 316:usb.c         **** 					list += sizeof(struct descriptor_list_struct);
 317:usb.c         **** 					continue;
 318:usb.c         **** 				}
 319:usb.c         **** 				list += 2;
 320:usb.c         **** 				desc_val = pgm_read_word(list);
 302               		.loc 1 320 0
 303 0084 F901      		movw r30,r18
 304 0086 3296      		adiw r30,2
 305               	.LVL15:
 306               	/* #APP */
 307               	 ;  320 "usb.c" 1
 308 0088 A591      		lpm r26, Z+
 309 008a B491      		lpm r27, Z
 310               		
 311               	 ;  0 "" 2
 312               	.LVL16:
 313               	/* #NOAPP */
 314               	.LBE70:
 321:usb.c         **** 				if (desc_val != wIndex) {
 315               		.loc 1 321 0
 316 008c 0A17      		cp r16,r26
 317 008e 1B07      		cpc r17,r27
 318 0090 01F0      		breq .+2
 319 0092 00C0      		rjmp .L19
 320               	.LVL17:
 322:usb.c         **** 					list += sizeof(struct descriptor_list_struct)-2;
 323:usb.c         **** 					continue;
 324:usb.c         **** 				}
 325:usb.c         **** 				list += 2;
 321               		.loc 1 325 0
 322 0094 F901      		movw r30,r18
 323 0096 3496      		adiw r30,4
 324               	.LVL18:
 325               	.LBB71:
 326:usb.c         **** 				desc_addr = (const uint8_t *)pgm_read_word(list);
 326               		.loc 1 326 0
 327               	/* #APP */
 328               	 ;  326 "usb.c" 1
 329 0098 4591      		lpm r20, Z+
 330 009a 5491      		lpm r21, Z
 331               		
 332               	 ;  0 "" 2
 333               	.LVL19:
 334               	/* #NOAPP */
 335               	.LBE71:
 327:usb.c         **** 				list += 2;
 336               		.loc 1 327 0
 337 009c F901      		movw r30,r18
 338 009e 3696      		adiw r30,6
 339               	.LVL20:
 340               	.LBB72:
 328:usb.c         **** 				desc_length = pgm_read_byte(list);
 341               		.loc 1 328 0
 342               	/* #APP */
 343               	 ;  328 "usb.c" 1
 344 00a0 E491      		lpm r30, Z
 345               		
 346               	 ;  0 "" 2
 347               	.LVL21:
 348               	/* #NOAPP */
 349               	.LBE72:
 305:usb.c         ****                 UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
 350               		.loc 1 305 0
 351 00a2 90E0      		ldi r25,0
 352 00a4 962B      		or r25,r22
 329:usb.c         **** 				break;
 330:usb.c         **** 			}
 331:usb.c         **** 			len = (wLength < 256) ? wLength : 255;
 353               		.loc 1 331 0
 354 00a6 8F3F      		cpi r24,-1
 355 00a8 9105      		cpc r25,__zero_reg__
 356 00aa 01F0      		breq .L20
 357 00ac 00F0      		brlo .L20
 358 00ae 8FEF      		ldi r24,lo8(-1)
 359 00b0 90E0      		ldi r25,0
 360               	.LVL22:
 361               	.L20:
 362 00b2 E817      		cp r30,r24
 363 00b4 00F4      		brsh .L21
 364 00b6 8E2F      		mov r24,r30
 365               	.L21:
 366               	.LBB73:
 367               	.LBB74:
 263:usb.c         **** }
 368               		.loc 1 263 0
 369 00b8 3EEF      		ldi r19,lo8(-2)
 370               	.LVL23:
 371               	.L25:
 372               	.LBE74:
 373               	.LBE73:
 332:usb.c         **** 			if (len > desc_length) len = desc_length;
 333:usb.c         **** 			do {
 334:usb.c         **** 				// wait for host ready for IN packet
 335:usb.c         **** 				do {
 336:usb.c         **** 					i = UEINTX;
 374               		.loc 1 336 0 discriminator 1
 375 00ba 9091 E800 		lds r25,232
 376               	.LVL24:
 337:usb.c         **** 				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
 377               		.loc 1 337 0 discriminator 1
 378 00be 292F      		mov r18,r25
 379 00c0 2570      		andi r18,lo8(5)
 380 00c2 01F0      		breq .L25
 338:usb.c         **** 				if (i & (1<<RXOUTI)) return;	// abort
 381               		.loc 1 338 0
 382 00c4 92FD      		sbrc r25,2
 383 00c6 00C0      		rjmp .L14
 339:usb.c         **** 				// send IN packet
 340:usb.c         **** 				n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
 384               		.loc 1 340 0
 385 00c8 982F      		mov r25,r24
 386               	.LVL25:
 387 00ca 8132      		cpi r24,lo8(33)
 388 00cc 00F0      		brlo .L27
 389 00ce 90E2      		ldi r25,lo8(32)
 390               	.L27:
 391               	.LVL26:
 392 00d0 FA01      		movw r30,r20
 341:usb.c         **** 				for (i = n; i; i--) {
 393               		.loc 1 341 0
 394 00d2 292F      		mov r18,r25
 395               	.LVL27:
 396               	.L28:
 397               		.loc 1 341 0 is_stmt 0 discriminator 1
 398 00d4 2111      		cpse r18,__zero_reg__
 399 00d6 00C0      		rjmp .L29
 400 00d8 490F      		add r20,r25
 401 00da 511D      		adc r21,__zero_reg__
 342:usb.c         **** 					UEDATX = pgm_read_byte(desc_addr++);
 343:usb.c         **** 				}
 344:usb.c         **** 				len -= n;
 402               		.loc 1 344 0 is_stmt 1
 403 00dc 891B      		sub r24,r25
 404               	.LVL28:
 405               	.LBB76:
 406               	.LBB75:
 263:usb.c         **** }
 407               		.loc 1 263 0
 408 00de 3093 E800 		sts 232,r19
 409               	.LBE75:
 410               	.LBE76:
 345:usb.c         **** 				usb_send_in();
 346:usb.c         **** 			} while (len || n == ENDPOINT0_SIZE);
 411               		.loc 1 346 0
 412 00e2 8111      		cpse r24,__zero_reg__
 413 00e4 00C0      		rjmp .L25
 414               		.loc 1 346 0 is_stmt 0 discriminator 1
 415 00e6 9032      		cpi r25,lo8(32)
 416 00e8 01F0      		breq .L25
 417               	.LVL29:
 418               	.L14:
 419               	/* epilogue start */
 347:usb.c         **** 			return;
 348:usb.c         ****                 }
 349:usb.c         **** 		if (bRequest == SET_ADDRESS) {
 350:usb.c         **** 			usb_send_in();
 351:usb.c         **** 			usb_wait_in_ready();
 352:usb.c         **** 			UDADDR = wValue | (1<<ADDEN);
 353:usb.c         **** 			return;
 354:usb.c         **** 		}
 355:usb.c         **** 		if (bRequest == SET_CONFIGURATION && bmRequestType == 0) {
 356:usb.c         **** 			usb_configuration = wValue;
 357:usb.c         **** 			usb_send_in();
 358:usb.c         **** 			cfg = endpoint_config_table;
 359:usb.c         **** 			for (i=1; i<5; i++) {
 360:usb.c         **** 				UENUM = i;
 361:usb.c         **** 				en = pgm_read_byte(cfg++);
 362:usb.c         **** 				UECONX = en;
 363:usb.c         **** 				if (en) {
 364:usb.c         **** 					UECFG0X = pgm_read_byte(cfg++);
 365:usb.c         **** 					UECFG1X = pgm_read_byte(cfg++);
 366:usb.c         **** 				}
 367:usb.c         **** 			}
 368:usb.c         ****         		UERST = 0x1E;
 369:usb.c         ****         		UERST = 0;
 370:usb.c         **** 			return;
 371:usb.c         **** 		}
 372:usb.c         **** 		if (bRequest == GET_CONFIGURATION && bmRequestType == 0x80) {
 373:usb.c         **** 			usb_wait_in_ready();
 374:usb.c         **** 			UEDATX = usb_configuration;
 375:usb.c         **** 			usb_send_in();
 376:usb.c         **** 			return;
 377:usb.c         **** 		}
 378:usb.c         **** 
 379:usb.c         **** 		if (bRequest == GET_STATUS) {
 380:usb.c         **** 			usb_wait_in_ready();
 381:usb.c         **** 			i = 0;
 382:usb.c         **** 			if (bmRequestType == 0x82) {
 383:usb.c         **** 				UENUM = wIndex;
 384:usb.c         **** 				if (UECONX & (1<<STALLRQ)) i = 1;
 385:usb.c         **** 				UENUM = 0;
 386:usb.c         **** 			}
 387:usb.c         **** 			UEDATX = i;
 388:usb.c         **** 			UEDATX = 0;
 389:usb.c         **** 			usb_send_in();
 390:usb.c         **** 			return;
 391:usb.c         **** 		}
 392:usb.c         **** 		if ((bRequest == CLEAR_FEATURE || bRequest == SET_FEATURE)
 393:usb.c         **** 		  && bmRequestType == 0x02 && wValue == 0) {
 394:usb.c         **** 			i = wIndex & 0x7F;
 395:usb.c         **** 			if (i >= 1 && i <= MAX_ENDPOINT) {
 396:usb.c         **** 				usb_send_in();
 397:usb.c         **** 				UENUM = i;
 398:usb.c         **** 				if (bRequest == SET_FEATURE) {
 399:usb.c         **** 					UECONX = (1<<STALLRQ)|(1<<EPEN);
 400:usb.c         **** 				} else {
 401:usb.c         **** 					UECONX = (1<<STALLRQC)|(1<<RSTDT)|(1<<EPEN);
 402:usb.c         **** 					UERST = (1 << i);
 403:usb.c         **** 					UERST = 0;
 404:usb.c         **** 				}
 405:usb.c         **** 				return;
 406:usb.c         **** 			}
 407:usb.c         **** 		}
 408:usb.c         **** 		if (wIndex == 0) {
 409:usb.c         **** 			if (bmRequestType == 0x21 && bRequest == HID_SET_REPORT) {
 410:usb.c         **** 				uint8_t buf[6];
 411:usb.c         **** 				len = RX_SIZE;
 412:usb.c         **** 				do {
 413:usb.c         **** 					n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
 414:usb.c         **** 					usb_wait_receive_out();
 415:usb.c         **** 					buf[0] = UEDATX;
 416:usb.c         **** 					buf[1] = UEDATX;
 417:usb.c         **** 					buf[2] = UEDATX;
 418:usb.c         **** 					buf[3] = UEDATX;
 419:usb.c         **** 					buf[4] = UEDATX;
 420:usb.c         **** 					buf[5] = UEDATX;
 421:usb.c         **** 					if (buf[0] == 'r' && buf[1] == 'e' && buf[2] == 'b'
 422:usb.c         **** 					 && buf[3] == 'o' && buf[4] == 'o' && buf[5] == 't') {
 423:usb.c         **** 						// When we get the "reboot" message,
 424:usb.c         **** 						// pulse all port B, C, & D pins low
 425:usb.c         **** 						PORTB = 0, PORTC = 0, PORTD = 0;
 426:usb.c         **** 						DDRB = 0xFF, DDRC = 0xFF, DDRD = 0xFF;
 427:usb.c         **** 						_delay_us(25);
 428:usb.c         **** 						DDRB = 0, DDRC = 0, DDRD = 0;
 429:usb.c         **** 						PORTB = 0xFF, PORTC = 0xFF, PORTD = 0xFF;
 430:usb.c         **** 						//DDRD = 0x40;
 431:usb.c         **** 						//PORTD = 0x40;
 432:usb.c         **** 					}
 433:usb.c         **** 					// ignore incoming bytes
 434:usb.c         **** 					usb_ack_out();
 435:usb.c         **** 					len -= n;
 436:usb.c         **** 				} while (len);
 437:usb.c         **** 				usb_wait_in_ready();
 438:usb.c         **** 				usb_send_in();
 439:usb.c         **** 				return;
 440:usb.c         **** 			}
 441:usb.c         **** 		}
 442:usb.c         **** 	}
 443:usb.c         **** 	UECONX = (1<<STALLRQ) | (1<<EPEN);	// stall
 444:usb.c         **** }
 420               		.loc 1 444 0 is_stmt 1
 421 00ea FF91      		pop r31
 422 00ec EF91      		pop r30
 423 00ee DF91      		pop r29
 424 00f0 CF91      		pop r28
 425 00f2 BF91      		pop r27
 426 00f4 AF91      		pop r26
 427 00f6 9F91      		pop r25
 428 00f8 8F91      		pop r24
 429 00fa 7F91      		pop r23
 430 00fc 6F91      		pop r22
 431 00fe 5F91      		pop r21
 432 0100 4F91      		pop r20
 433 0102 3F91      		pop r19
 434 0104 2F91      		pop r18
 435 0106 1F91      		pop r17
 436 0108 0F91      		pop r16
 437 010a FF90      		pop r15
 438 010c EF90      		pop r14
 439 010e 0F90      		pop r0
 440 0110 0FBE      		out __SREG__,r0
 441 0112 0F90      		pop r0
 442 0114 1F90      		pop r1
 443 0116 1895      		reti
 444               	.LVL30:
 445               	.L19:
 446 0118 295F      		subi r18,-7
 447 011a 3F4F      		sbci r19,-1
 310:usb.c         **** 					UECONX = (1<<STALLRQ)|(1<<EPEN);  //stall
 448               		.loc 1 310 0
 449 011c 4217      		cp r20,r18
 450 011e 5307      		cpc r21,r19
 451 0120 01F0      		breq .+2
 452 0122 00C0      		rjmp .L24
 453               	.LVL31:
 454               	.L15:
 443:usb.c         **** }
 455               		.loc 1 443 0
 456 0124 81E2      		ldi r24,lo8(33)
 457 0126 8093 EB00 		sts 235,r24
 458 012a 00C0      		rjmp .L14
 459               	.LVL32:
 460               	.L29:
 461               	.LBB77:
 342:usb.c         **** 				}
 462               		.loc 1 342 0 discriminator 3
 463               	/* #APP */
 464               	 ;  342 "usb.c" 1
 465 012c 6491      		lpm r22, Z
 466               		
 467               	 ;  0 "" 2
 468               	.LVL33:
 469               	/* #NOAPP */
 470               	.LBE77:
 471 012e 6093 F100 		sts 241,r22
 341:usb.c         **** 					UEDATX = pgm_read_byte(desc_addr++);
 472               		.loc 1 341 0 discriminator 3
 473 0132 2150      		subi r18,lo8(-(-1))
 474               	.LVL34:
 475 0134 3196      		adiw r30,1
 476               	.LVL35:
 477 0136 00C0      		rjmp .L28
 478               	.LVL36:
 479               	.L55:
 349:usb.c         **** 			usb_send_in();
 480               		.loc 1 349 0
 481 0138 C530      		cpi r28,lo8(5)
 482 013a 01F4      		brne .L32
 483               	.LBB78:
 484               	.LBB79:
 263:usb.c         **** }
 485               		.loc 1 263 0
 486 013c 8EEF      		ldi r24,lo8(-2)
 487               	.LVL37:
 488 013e 8093 E800 		sts 232,r24
 489               	.LBE79:
 490               	.LBE78:
 351:usb.c         **** 			UDADDR = wValue | (1<<ADDEN);
 491               		.loc 1 351 0
 492 0142 0E94 0000 		call usb_wait_in_ready
 493               	.LVL38:
 352:usb.c         **** 			return;
 494               		.loc 1 352 0
 495 0146 8E2D      		mov r24,r14
 496 0148 8068      		ori r24,lo8(-128)
 497 014a 8093 E300 		sts 227,r24
 353:usb.c         **** 		}
 498               		.loc 1 353 0
 499 014e 00C0      		rjmp .L14
 500               	.LVL39:
 501               	.L32:
 355:usb.c         **** 			usb_configuration = wValue;
 502               		.loc 1 355 0
 503 0150 C930      		cpi r28,lo8(9)
 504 0152 01F4      		brne .L33
 355:usb.c         **** 			usb_configuration = wValue;
 505               		.loc 1 355 0 is_stmt 0 discriminator 1
 506 0154 D111      		cpse r29,__zero_reg__
 507 0156 00C0      		rjmp .L34
 356:usb.c         **** 			usb_send_in();
 508               		.loc 1 356 0 is_stmt 1
 509 0158 E092 0000 		sts usb_configuration,r14
 510               	.LBB80:
 511               	.LBB81:
 263:usb.c         **** }
 512               		.loc 1 263 0
 513 015c 8EEF      		ldi r24,lo8(-2)
 514               	.LVL40:
 515 015e 8093 E800 		sts 232,r24
 516               	.LVL41:
 517               	.LBE81:
 518               	.LBE80:
 359:usb.c         **** 				UENUM = i;
 519               		.loc 1 359 0
 520 0162 21E0      		ldi r18,lo8(1)
 358:usb.c         **** 			for (i=1; i<5; i++) {
 521               		.loc 1 358 0
 522 0164 80E0      		ldi r24,lo8(endpoint_config_table)
 523 0166 90E0      		ldi r25,hi8(endpoint_config_table)
 524               	.LVL42:
 525               	.L36:
 360:usb.c         **** 				en = pgm_read_byte(cfg++);
 526               		.loc 1 360 0
 527 0168 2093 E900 		sts 233,r18
 528               	.LBB82:
 361:usb.c         **** 				UECONX = en;
 529               		.loc 1 361 0
 530 016c AC01      		movw r20,r24
 531 016e 4F5F      		subi r20,-1
 532 0170 5F4F      		sbci r21,-1
 533               	.LVL43:
 534 0172 FC01      		movw r30,r24
 535               	/* #APP */
 536               	 ;  361 "usb.c" 1
 537 0174 3491      		lpm r19, Z
 538               		
 539               	 ;  0 "" 2
 540               	.LVL44:
 541               	/* #NOAPP */
 542               	.LBE82:
 362:usb.c         **** 				if (en) {
 543               		.loc 1 362 0
 544 0176 3093 EB00 		sts 235,r19
 363:usb.c         **** 					UECFG0X = pgm_read_byte(cfg++);
 545               		.loc 1 363 0
 546 017a 3323      		tst r19
 547 017c 01F0      		breq .L43
 548               	.LVL45:
 549               	.LBB83:
 364:usb.c         **** 					UECFG1X = pgm_read_byte(cfg++);
 550               		.loc 1 364 0
 551 017e FA01      		movw r30,r20
 552               	/* #APP */
 553               	 ;  364 "usb.c" 1
 554 0180 4491      		lpm r20, Z
 555               		
 556               	 ;  0 "" 2
 557               	.LVL46:
 558               	/* #NOAPP */
 559               	.LBE83:
 560 0182 4093 EC00 		sts 236,r20
 561               	.LVL47:
 562               	.LBB84:
 365:usb.c         **** 				}
 563               		.loc 1 365 0
 564 0186 3196      		adiw r30,1
 565               	.LVL48:
 566               	/* #APP */
 567               	 ;  365 "usb.c" 1
 568 0188 E491      		lpm r30, Z
 569               		
 570               	 ;  0 "" 2
 571               	.LVL49:
 572               	/* #NOAPP */
 573 018a 0396      		adiw r24,3
 574               	.LVL50:
 575               	.LBE84:
 576 018c E093 ED00 		sts 237,r30
 577               	.LVL51:
 578               	.L35:
 359:usb.c         **** 				UENUM = i;
 579               		.loc 1 359 0 discriminator 2
 580 0190 2F5F      		subi r18,lo8(-(1))
 581               	.LVL52:
 582 0192 2530      		cpi r18,lo8(5)
 583 0194 01F4      		brne .L36
 368:usb.c         ****         		UERST = 0;
 584               		.loc 1 368 0
 585 0196 8EE1      		ldi r24,lo8(30)
 586               	.LVL53:
 587               	.L56:
 402:usb.c         **** 					UERST = 0;
 588               		.loc 1 402 0
 589 0198 8093 EA00 		sts 234,r24
 403:usb.c         **** 				}
 590               		.loc 1 403 0
 591 019c 1092 EA00 		sts 234,__zero_reg__
 592 01a0 00C0      		rjmp .L14
 593               	.LVL54:
 594               	.L43:
 595               	.LBB85:
 361:usb.c         **** 				UECONX = en;
 596               		.loc 1 361 0
 597 01a2 CA01      		movw r24,r20
 598               	.LVL55:
 599 01a4 00C0      		rjmp .L35
 600               	.LVL56:
 601               	.L33:
 602               	.LBE85:
 372:usb.c         **** 			usb_wait_in_ready();
 603               		.loc 1 372 0
 604 01a6 C830      		cpi r28,lo8(8)
 605 01a8 01F4      		brne .L37
 372:usb.c         **** 			usb_wait_in_ready();
 606               		.loc 1 372 0 is_stmt 0 discriminator 1
 607 01aa D038      		cpi r29,lo8(-128)
 608 01ac 01F0      		breq .+2
 609 01ae 00C0      		rjmp .L34
 373:usb.c         **** 			UEDATX = usb_configuration;
 610               		.loc 1 373 0 is_stmt 1
 611 01b0 0E94 0000 		call usb_wait_in_ready
 612               	.LVL57:
 374:usb.c         **** 			usb_send_in();
 613               		.loc 1 374 0
 614 01b4 8091 0000 		lds r24,usb_configuration
 615 01b8 8093 F100 		sts 241,r24
 616               	.LVL58:
 617               	.L57:
 618               	.LBB86:
 619               	.LBB87:
 620               	.LBB88:
 263:usb.c         **** }
 621               		.loc 1 263 0
 622 01bc 8EEF      		ldi r24,lo8(-2)
 623 01be 8093 E800 		sts 232,r24
 624 01c2 00C0      		rjmp .L14
 625               	.LVL59:
 626               	.L37:
 627               	.LBE88:
 628               	.LBE87:
 629               	.LBE86:
 379:usb.c         **** 			usb_wait_in_ready();
 630               		.loc 1 379 0
 631 01c4 C111      		cpse r28,__zero_reg__
 632 01c6 00C0      		rjmp .L38
 380:usb.c         **** 			i = 0;
 633               		.loc 1 380 0
 634 01c8 0E94 0000 		call usb_wait_in_ready
 635               	.LVL60:
 382:usb.c         **** 				UENUM = wIndex;
 636               		.loc 1 382 0
 637 01cc D238      		cpi r29,lo8(-126)
 638 01ce 01F4      		brne .L39
 383:usb.c         **** 				if (UECONX & (1<<STALLRQ)) i = 1;
 639               		.loc 1 383 0
 640 01d0 0093 E900 		sts 233,r16
 384:usb.c         **** 				UENUM = 0;
 641               		.loc 1 384 0
 642 01d4 C091 EB00 		lds r28,235
 643               	.LVL61:
 644 01d8 C5FB      		bst r28,5
 645 01da CC27      		clr r28
 646 01dc C0F9      		bld r28,0
 647               	.LVL62:
 385:usb.c         **** 			}
 648               		.loc 1 385 0
 649 01de 1092 E900 		sts 233,__zero_reg__
 650               	.LVL63:
 651               	.L39:
 387:usb.c         **** 			UEDATX = 0;
 652               		.loc 1 387 0
 653 01e2 C093 F100 		sts 241,r28
 388:usb.c         **** 			usb_send_in();
 654               		.loc 1 388 0
 655 01e6 1092 F100 		sts 241,__zero_reg__
 656 01ea 00C0      		rjmp .L57
 657               	.LVL64:
 658               	.L38:
 392:usb.c         **** 		  && bmRequestType == 0x02 && wValue == 0) {
 659               		.loc 1 392 0
 660 01ec 8C2F      		mov r24,r28
 661               	.LVL65:
 662 01ee 8D7F      		andi r24,lo8(-3)
 663 01f0 8130      		cpi r24,lo8(1)
 664 01f2 01F4      		brne .L34
 393:usb.c         **** 			i = wIndex & 0x7F;
 665               		.loc 1 393 0
 666 01f4 D230      		cpi r29,lo8(2)
 667 01f6 01F4      		brne .L34
 393:usb.c         **** 			i = wIndex & 0x7F;
 668               		.loc 1 393 0 is_stmt 0 discriminator 1
 669 01f8 EF28      		or r14,r15
 670 01fa 01F0      		breq .+2
 671 01fc 00C0      		rjmp .L15
 394:usb.c         **** 			if (i >= 1 && i <= MAX_ENDPOINT) {
 672               		.loc 1 394 0 is_stmt 1
 673 01fe 0F77      		andi r16,lo8(127)
 674               	.LVL66:
 395:usb.c         **** 				usb_send_in();
 675               		.loc 1 395 0
 676 0200 8FEF      		ldi r24,lo8(-1)
 677 0202 800F      		add r24,r16
 678 0204 8430      		cpi r24,lo8(4)
 679 0206 00F0      		brlo .+2
 680 0208 00C0      		rjmp .L15
 681               	.LBB95:
 682               	.LBB96:
 263:usb.c         **** }
 683               		.loc 1 263 0
 684 020a 8EEF      		ldi r24,lo8(-2)
 685 020c 8093 E800 		sts 232,r24
 686               	.LBE96:
 687               	.LBE95:
 397:usb.c         **** 				if (bRequest == SET_FEATURE) {
 688               		.loc 1 397 0
 689 0210 0093 E900 		sts 233,r16
 398:usb.c         **** 					UECONX = (1<<STALLRQ)|(1<<EPEN);
 690               		.loc 1 398 0
 691 0214 C330      		cpi r28,lo8(3)
 692 0216 01F4      		brne .+2
 693 0218 00C0      		rjmp .L15
 401:usb.c         **** 					UERST = (1 << i);
 694               		.loc 1 401 0
 695 021a 89E1      		ldi r24,lo8(25)
 696 021c 8093 EB00 		sts 235,r24
 402:usb.c         **** 					UERST = 0;
 697               		.loc 1 402 0
 698 0220 81E0      		ldi r24,lo8(1)
 699 0222 90E0      		ldi r25,0
 700 0224 00C0      		rjmp 2f
 701               		1:
 702 0226 880F      		lsl r24
 703               		2:
 704 0228 0A95      		dec r16
 705 022a 02F4      		brpl 1b
 706 022c 00C0      		rjmp .L56
 707               	.LVL67:
 708               	.L34:
 408:usb.c         **** 			if (bmRequestType == 0x21 && bRequest == HID_SET_REPORT) {
 709               		.loc 1 408 0
 710 022e 012B      		or r16,r17
 711 0230 01F0      		breq .+2
 712 0232 00C0      		rjmp .L15
 409:usb.c         **** 				uint8_t buf[6];
 713               		.loc 1 409 0
 714 0234 D132      		cpi r29,lo8(33)
 715 0236 01F0      		breq .+2
 716 0238 00C0      		rjmp .L15
 409:usb.c         **** 				uint8_t buf[6];
 717               		.loc 1 409 0 is_stmt 0 discriminator 1
 718 023a C930      		cpi r28,lo8(9)
 719 023c 01F0      		breq .+2
 720 023e 00C0      		rjmp .L15
 721               	.L41:
 722               	.LBB97:
 723               	.LBB89:
 724               	.LBB90:
 267:usb.c         **** }
 725               		.loc 1 267 0 is_stmt 1
 726 0240 8091 E800 		lds r24,232
 727 0244 82FF      		sbrs r24,2
 728 0246 00C0      		rjmp .L41
 729               	.LBE90:
 730               	.LBE89:
 415:usb.c         **** 					buf[1] = UEDATX;
 731               		.loc 1 415 0
 732 0248 5091 F100 		lds r21,241
 733               	.LVL68:
 416:usb.c         **** 					buf[2] = UEDATX;
 734               		.loc 1 416 0
 735 024c 4091 F100 		lds r20,241
 736               	.LVL69:
 417:usb.c         **** 					buf[3] = UEDATX;
 737               		.loc 1 417 0
 738 0250 3091 F100 		lds r19,241
 739               	.LVL70:
 418:usb.c         **** 					buf[4] = UEDATX;
 740               		.loc 1 418 0
 741 0254 2091 F100 		lds r18,241
 742               	.LVL71:
 419:usb.c         **** 					buf[5] = UEDATX;
 743               		.loc 1 419 0
 744 0258 9091 F100 		lds r25,241
 745               	.LVL72:
 420:usb.c         **** 					if (buf[0] == 'r' && buf[1] == 'e' && buf[2] == 'b'
 746               		.loc 1 420 0
 747 025c 8091 F100 		lds r24,241
 748               	.LVL73:
 421:usb.c         **** 					 && buf[3] == 'o' && buf[4] == 'o' && buf[5] == 't') {
 749               		.loc 1 421 0
 750 0260 5237      		cpi r21,lo8(114)
 751 0262 01F4      		brne .L42
 421:usb.c         **** 					 && buf[3] == 'o' && buf[4] == 'o' && buf[5] == 't') {
 752               		.loc 1 421 0 is_stmt 0 discriminator 1
 753 0264 4536      		cpi r20,lo8(101)
 754 0266 01F4      		brne .L42
 421:usb.c         **** 					 && buf[3] == 'o' && buf[4] == 'o' && buf[5] == 't') {
 755               		.loc 1 421 0 discriminator 2
 756 0268 3236      		cpi r19,lo8(98)
 757 026a 01F4      		brne .L42
 422:usb.c         **** 						// When we get the "reboot" message,
 758               		.loc 1 422 0 is_stmt 1
 759 026c 2F36      		cpi r18,lo8(111)
 760 026e 01F4      		brne .L42
 422:usb.c         **** 						// When we get the "reboot" message,
 761               		.loc 1 422 0 is_stmt 0 discriminator 1
 762 0270 9F36      		cpi r25,lo8(111)
 763 0272 01F4      		brne .L42
 422:usb.c         **** 						// When we get the "reboot" message,
 764               		.loc 1 422 0 discriminator 2
 765 0274 8437      		cpi r24,lo8(116)
 766 0276 01F4      		brne .L42
 425:usb.c         **** 						DDRB = 0xFF, DDRC = 0xFF, DDRD = 0xFF;
 767               		.loc 1 425 0 is_stmt 1
 768 0278 15B8      		out 0x5,__zero_reg__
 769 027a 18B8      		out 0x8,__zero_reg__
 770 027c 1BB8      		out 0xb,__zero_reg__
 426:usb.c         **** 						_delay_us(25);
 771               		.loc 1 426 0
 772 027e 8FEF      		ldi r24,lo8(-1)
 773               	.LVL74:
 774 0280 84B9      		out 0x4,r24
 775 0282 87B9      		out 0x7,r24
 776 0284 8AB9      		out 0xa,r24
 777               	.LVL75:
 778               	.LBB91:
 779               	.LBB92:
 780               		.file 2 "/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 189:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #else
 190:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	{
 196:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 		{
 200:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 		}
 204:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 		return;
 205:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	}
 206:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	else
 207:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #endif
 210:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** }
 211:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 212:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** /**
 213:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 215:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 217:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 220:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 222:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 226:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 231:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 236:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    respectively.
 240:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 241:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    \note
 242:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 243:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 253:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****  */
 254:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** void
 255:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** {
 257:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 265:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 268:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 271:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	#else
 272:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 		//round up by default
 273:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	#endif
 275:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 
 276:/usr/local/Cellar/avr-gcc/6.3.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 781               		.loc 2 276 0
 782 0286 F8E0      		ldi r31,lo8(8)
 783 0288 FA95      	1:	dec r31
 784 028a 01F4      		brne 1b
 785 028c 0000      		nop
 786               	.LVL76:
 787               	.LBE92:
 788               	.LBE91:
 428:usb.c         **** 						PORTB = 0xFF, PORTC = 0xFF, PORTD = 0xFF;
 789               		.loc 1 428 0
 790 028e 14B8      		out 0x4,__zero_reg__
 791 0290 17B8      		out 0x7,__zero_reg__
 792 0292 1AB8      		out 0xa,__zero_reg__
 429:usb.c         **** 						//DDRD = 0x40;
 793               		.loc 1 429 0
 794 0294 85B9      		out 0x5,r24
 795 0296 88B9      		out 0x8,r24
 796 0298 8BB9      		out 0xb,r24
 797               	.LVL77:
 798               	.L42:
 799               	.LBB93:
 800               	.LBB94:
 271:usb.c         **** }
 801               		.loc 1 271 0
 802 029a 8BEF      		ldi r24,lo8(-5)
 803 029c 8093 E800 		sts 232,r24
 804               	.LVL78:
 805               	.LBE94:
 806               	.LBE93:
 437:usb.c         **** 				usb_send_in();
 807               		.loc 1 437 0
 808 02a0 0E94 0000 		call usb_wait_in_ready
 809               	.LVL79:
 810 02a4 00C0      		rjmp .L57
 811               	.LBE97:
 812               		.cfi_endproc
 813               	.LFE13:
 815               		.local	usb_configuration
 816               		.comm	usb_configuration,1,1
 817               	.global	descriptor_list
 818               		.section	.progmem.data,"a",@progbits
 821               	descriptor_list:
 822 0000 0001      		.word	256
 823 0002 0000      		.word	0
 824 0004 0000      		.word	device_descriptor
 825 0006 12        		.byte	18
 826 0007 0002      		.word	512
 827 0009 0000      		.word	0
 828 000b 0000      		.word	config1_descriptor
 829 000d 22        		.byte	34
 830 000e 0022      		.word	8704
 831 0010 0000      		.word	0
 832 0012 0000      		.word	rawhid_hid_report_desc
 833 0014 16        		.byte	22
 834 0015 0021      		.word	8448
 835 0017 0000      		.word	0
 836 0019 0000      		.word	config1_descriptor+18
 837 001b 09        		.byte	9
 838 001c 0003      		.word	768
 839 001e 0000      		.word	0
 840 0020 0000      		.word	string0
 841 0022 04        		.byte	4
 842 0023 0103      		.word	769
 843 0025 0904      		.word	1033
 844 0027 0000      		.word	string1
 845 0029 0A        		.byte	10
 846 002a 0203      		.word	770
 847 002c 0904      		.word	1033
 848 002e 0000      		.word	string2
 849 0030 12        		.byte	18
 850               	.global	string2
 853               	string2:
 854 0031 12        		.byte	18
 855 0032 03        		.byte	3
 856 0033 5200      		.string	"R"
 857 0035 6500      		.string	"e"
 858 0037 6200      		.string	"b"
 859 0039 6F00      		.string	"o"
 860 003b 6F00      		.string	"o"
 861 003d 7400      		.string	"t"
 862 003f 6F00      		.string	"o"
 863 0041 7200      		.string	"r"
 864 0043 00        		.string	""
 865 0044 00        		.string	""
 866               	.global	string1
 869               	string1:
 870 0045 0A        		.byte	10
 871 0046 03        		.byte	3
 872 0047 5000      		.string	"P"
 873 0049 4A00      		.string	"J"
 874 004b 5200      		.string	"R"
 875 004d 4300      		.string	"C"
 876 004f 00        		.string	""
 877 0050 00        		.string	""
 878               	.global	string0
 881               	string0:
 882 0051 04        		.byte	4
 883 0052 03        		.byte	3
 884 0053 0904      		.word	1033
 885               	.global	config1_descriptor
 888               	config1_descriptor:
 889 0055 09        		.byte	9
 890 0056 02        		.byte	2
 891 0057 22        		.byte	34
 892 0058 00        		.byte	0
 893 0059 01        		.byte	1
 894 005a 01        		.byte	1
 895 005b 00        		.byte	0
 896 005c C0        		.byte	-64
 897 005d 32        		.byte	50
 898 005e 09        		.byte	9
 899 005f 04        		.byte	4
 900 0060 00        		.byte	0
 901 0061 00        		.byte	0
 902 0062 01        		.byte	1
 903 0063 03        		.byte	3
 904 0064 00        		.byte	0
 905 0065 00        		.byte	0
 906 0066 00        		.byte	0
 907 0067 09        		.byte	9
 908 0068 21        		.byte	33
 909 0069 11        		.byte	17
 910 006a 01        		.byte	1
 911 006b 00        		.byte	0
 912 006c 01        		.byte	1
 913 006d 22        		.byte	34
 914 006e 16        		.byte	22
 915 006f 00        		.byte	0
 916 0070 07        		.byte	7
 917 0071 05        		.byte	5
 918 0072 81        		.byte	-127
 919 0073 03        		.byte	3
 920 0074 08        		.byte	8
 921 0075 00        		.byte	0
 922 0076 80        		.byte	-128
 923               	.global	rawhid_hid_report_desc
 926               	rawhid_hid_report_desc:
 927 0077 06        		.byte	6
 928 0078 00        		.byte	0
 929 0079 FF        		.byte	-1
 930 007a 0A        		.byte	10
 931 007b 00        		.byte	0
 932 007c 01        		.byte	1
 933 007d A1        		.byte	-95
 934 007e 01        		.byte	1
 935 007f 75        		.byte	117
 936 0080 08        		.byte	8
 937 0081 15        		.byte	21
 938 0082 00        		.byte	0
 939 0083 26        		.byte	38
 940 0084 FF        		.byte	-1
 941 0085 00        		.byte	0
 942 0086 95        		.byte	-107
 943 0087 06        		.byte	6
 944 0088 09        		.byte	9
 945 0089 02        		.byte	2
 946 008a 91        		.byte	-111
 947 008b 02        		.byte	2
 948 008c C0        		.byte	-64
 949               	.global	device_descriptor
 952               	device_descriptor:
 953 008d 12        		.byte	18
 954 008e 01        		.byte	1
 955 008f 00        		.byte	0
 956 0090 02        		.byte	2
 957 0091 00        		.byte	0
 958 0092 00        		.byte	0
 959 0093 00        		.byte	0
 960 0094 20        		.byte	32
 961 0095 C0        		.byte	-64
 962 0096 16        		.byte	22
 963 0097 77        		.byte	119
 964 0098 04        		.byte	4
 965 0099 00        		.byte	0
 966 009a 01        		.byte	1
 967 009b 01        		.byte	1
 968 009c 02        		.byte	2
 969 009d 00        		.byte	0
 970 009e 01        		.byte	1
 973               	endpoint_config_table:
 974 009f 01        		.byte	1
 975 00a0 C1        		.byte	-63
 976 00a1 02        		.byte	2
 977 00a2 00        		.byte	0
 978 00a3 00        		.byte	0
 979 00a4 00        		.byte	0
 980               		.text
 981               	.Letext0:
 982               		.file 3 "/usr/local/Cellar/avr-gcc/6.3.0/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 usb.c
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:4      *ABS*:000000000000003f __SREG__
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:12     .text.usb_wait_in_ready:0000000000000000 usb_wait_in_ready
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:35     .text.usb_init:0000000000000000 usb_init
                             .bss:0000000000000000 usb_configuration
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:80     .text.__vector_10:0000000000000000 __vector_10
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:142    .text.__vector_11:0000000000000000 __vector_11
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:821    .progmem.data:0000000000000000 descriptor_list
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:973    .progmem.data:000000000000009f endpoint_config_table
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:952    .progmem.data:000000000000008d device_descriptor
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:888    .progmem.data:0000000000000055 config1_descriptor
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:926    .progmem.data:0000000000000077 rawhid_hid_report_desc
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:881    .progmem.data:0000000000000051 string0
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:869    .progmem.data:0000000000000045 string1
/var/folders/49/mkb0yr8d03vdllc73bnyn9600000gn/T//cczsE1x8.s:853    .progmem.data:0000000000000031 string2

UNDEFINED SYMBOLS
__do_clear_bss
